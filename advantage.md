# Преимущества

## Согласованность с бизнес-логикой проекта

Во-первых, можно не прятать сложные операции за скудным набором HTTP-глаголов и избыточными URI.

Есть предметные области, где операций в API должно быть больше чем сущностей.
Навскидку — проекты с непростыми бизнес-процессами, gamedev, мессенджеры и подобные realtime-штуки.

Нажатие кнопки "↑" под постом — это не изменение ресурса, а вызов целой цепочки событий, вплоть до выдачи автору поста значков или инвайтов.

Так стоит ли маскировать `post.like(id)` за `PUT /posts/{id}/likes`?

Здесь также стоит упомянуть CQRS, с которым RPC-шный API будет смотреться лучше.

Во-вторых, кодов ответа в HTTP всегда меньше, чем типов ошибок бизнес-логики, которые вы бы хотели возвращать на клиент.

Кто-то всегда возвращает 200-ку, кто-то ломает голову, пытаясь сопоставить ошибки с HTTP-кодами.

В JSON-RPC весь диапазон integer — ваш.

## JSON-RPC — стандарт, а не набор рекомендаций

Очень простой стандарт.

Данные запроса могут быть:

| REST | RPC 
| --- | --- 
| В URI запроса | -
| В GET-параметрах | -
| В HTTP-заголовках | -
| В теле запроса |  В теле запроса

Данные ответа могут быть:

| REST | RPC 
| --- | --- 
| В HTTP-коде ответа | -
| В HTTP-заголовках | -
| В теле ответа (формат не стандартизирован) | В теле ответа (формат стандартизирован)

`POST /server/{id}/status` или `PATCH /server/{id}`?
Это больше не имеет значения. Остается `POST /api`.

Нет никаких best practices с форумов, есть стандарт.
Нет разногласий в команде, есть стандарт.

Конечно же, качественно реализованный REST API можно полностью задокументировать. Однако…

Знаете, что и где нужно передать в запросе к Github API, чтобы получить объект reactions вместе с issue?

  Accept: application/vnd.github.squirrel-girl-preview

Хорошо это или плохо? Решайте сами, гуглите сами. Стандарта нет.

## Независимость от HTTP

В теории, принципы REST можно применять не только для API поверх HTTP.
На практике все по-другому.

JSON-RPC over HTTP безболезненно переносится на JSON-RPC over Websocket. Да хоть TCP.
Тело JSON-RPC запроса можно прямо в сыром виде бросить в очередь, чтобы обработать позже.

Больше нет проблем от размазывания бизнес-логики по транспортному уровню (HTTP).

HTTP 404:

| REST | RPC 
| --- | --- 
| Ресурса с таким идентификатором нет | -
| Здесь API нет | Здесь API нет

## Производительность

JSON-RPC пригодится, если у вас есть:

* Batch-запросы
* Нотификации, которые можно обрабатывать асинхронно
* Вебсокеты

Не то, чтобы это все нельзя было сделать без JSON-RPC. Но с ним — чуть легче.
